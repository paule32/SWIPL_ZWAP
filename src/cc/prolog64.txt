; -------------------------------------------
; help file for the Prolog-System v.0.0.1
;
; (c) 2023 by Jens Kallup
; all rights reserved.
; -------------------------------------------
.topic noContext=0
 Index ▄
  ▀▀▀▀▀▀
 This is the default Help page.
 You can Press ESC-Key to close this screen.
 
 {win32api:win32api_ENG}
 
.topic AsciiTable
zuzu

.topic NewPascal_ENG
 {ENG:NewProjectDialog_ENG} {DEU:NewPascal_DEU} {Content:Content_ENG}
 ════════════════════════════════════════════
 New Pascal Project ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Here, you can create a new Pascal Project or load an existing one.
It is possible, to mix the Project's.

.topic NewCPP_ENG
 {ENG:NewProjectDialog_ENG} {DEU:NewCPP_DEU} {Content:Content_ENG}
 ════════════════════════════════════════════
 New C/C++ Project ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Here, you can create a new C++ Project or load an existing one.
It is possible, to mix the Project's.

.topic NewDBASE_ENG
 {ENG:NewProjectDialog_ENG} {DEU:NewDBASE_DEU} {Content:Content_ENG}
 ════════════════════════════════════════════
 New dBASE Project ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Here, you can create a new dBASE Project or load an existing one.
It is possible, to mix the Project's.

.topic NewFortran_ENG
 {ENG:NewProjectDialog_ENG} {DEU:NewFortran_DEU} {Content:Content_ENG}
 ════════════════════════════════════════════
 New Fortran Project ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Here, you can create a new Fortran Project or load an existing one.
It is possible, to mix the Project's.

.topic NewProlog_ENG
 {ENG:NewProjectDialog_ENG} {DEU:NewProlog_DEU} {Content:Content_ENG}
 ════════════════════════════════════════════
 New Prolog Project ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Here, you can create a new Prolog Project or load an existing one.
It is possible, to mix the Project's.

.topic NewAssembler_ENG
 {ENG:NewProjectDialog_ENG} {DEU:NewAssembler_DEU} {Content:Content_ENG}
 ════════════════════════════════════════════
 New Assembler Project ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Here, you can create a new Assembler Project or load an existing one.
It is possible, to mix the Project's.

{supported keywords:ASM_Content_ENG}

.topic NewPascal_DEU
 {DEU:NewProjectDialog_DEU} {ENG:NewPascal_ENG} {Inhalt:Content_DEU}
 ════════════════════════════════════════════
 Neues Pascal Projekt ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Hier können Sie ein neues Pascal Projekt beginnen, oder ein existierendes
Projekt auf einen Datenträger zu öffnen.
Es ist möglich, unterschiedliche Projekte zu mischen.

.topic NewCPP_DEU
 {DEU:NewProjectDialog_DEU} {ENG:NewCPP_ENG} {Inhalt:Content_DEU}
 ════════════════════════════════════════════
 Neues C/C++ Projekt ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Hier können Sie ein neues C++ Projekt beginnen, oder ein existierendes
Projekt auf einen Datenträger zu öffnen.
Es ist möglich, unterschiedliche Projekte zu mischen.

.topic NewDBASE_DEU
 {DEU:NewProjectDialog_DEU} {ENG:NewDBASE_ENG} {Inhalt:Content_DEU}
 ════════════════════════════════════════════
 Neues dBASE Projekt ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Hier können Sie ein neues dBASE Projekt beginnen, oder ein existierendes
Projekt auf einen Datenträger zu öffnen.
Es ist möglich, unterschiedliche Projekte zu mischen.

.topic NewFortran_DEU
 {DEU:NewProjectDialog_DEU} {ENG:NewFortran_ENG} {Inhalt:Content_DEU}
 ════════════════════════════════════════════
 Neues Fortran Projekt ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Hier können Sie ein neues Fortran Projekt beginnen, oder ein existierendes
Projekt auf einen Datenträger zu öffnen.
Es ist möglich, unterschiedliche Projekte zu mischen.

.topic NewProlog_DEU
 {DEU:NewProjectDialog_DEU} {ENG:NewProlog_ENG} {Inhalt:Content_DEU}
 ════════════════════════════════════════════
 Neues Prolog Projekt ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Hier können Sie ein neues Prolog Projekt beginnen, oder ein existierendes
Projekt auf einen Datenträger zu öffnen.
Es ist möglich, unterschiedliche Projekte zu mischen.

.topic NewAssembler_DEU
 {DEU:NewProjectDialog_DEU} {ENG:NewAssembler_ENG} {Inhalt:Content_DEU}
 ════════════════════════════════════════════
 Neues Assembler Projekt ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
Hier können Sie ein neues Assembler Projekt beginnen, oder ein existierendes
Projekt auf einen Datenträger zu öffnen.
Es ist möglich, unterschiedliche Projekte zu mischen.

{unterstützte Anweisungen:ASM_Content_ENG}

.topic NewProjectDialog_ENG
 {ENG:NewProjectDialog_ENG} {DEU:NewProjectDialog_DEU} {Content:Content_ENG}
 ════════════════════════════════════════════
 New Project ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀
In this Dialog-Window, you can choose the
main-stream Project.

You can add, mix, and/or delete Projects
during the development Time.

.topic NewProjectDialog_DEU
 {ENG:NewProjectDialog_ENG} {DEU:NewProjectDialog_DEU} {Inhalt:Content_DEU}
 ════════════════════════════════════════════
 Neues Projekt ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀
In diesen Dialog-Fenster können Sie die Art
des zu erstellenden Haupt-Projektes festlegen.

Sie können Projekte während der Entwicklung
hinzufügen, mischen, oder löschen.

.topic Content_ENG
 {ENG:Content_ENG} {DEU:Content_DEU} - Content
 ════════════════════════════════════════════
 Content ▄
  ▀▀▀▀▀▀▀▀
The programming language PASCAL was developed in 1970 by
Niklaus Wirth at the ETH Zurich.
It was designed as a language that could be used for
for the education of programmers.
The language is simple and clearly structured and designed
so that it can be used on "smalu8" computers.
The PASCAL language was named from the French mathematician
Blaise Pascal, who invented one of the first mechanical
calculus machine in 1652.

Since 1985 was Turbo Pascal 3.0 the language standard on
DOS-Machines, and the Developement in the following years
over the versions 4 - 5.5 - 6 - 7 was constantly developed
further.
The Windows variant of PASCAL is DELPHI and it enjoys
increasing popularity today.

The goal in developing was to invent a language,
that:
 » based on a few fundamental concepts,
 » simple and clear language constructions,
 » has simple language rules (syntax),
 » generates efficient code with a simple compiler

The simplest programs essentially consist of
an input part, a processing part and an 
output part (IPO principle).
The individual parts are executed in sequence.
Such a string of instructions is called a sequence.


{Pascal-keywords:keywords_ENG}


; ---------------------------------------------------------------
; german - content
; ---------------------------------------------------------------
.topic Content_DEU
 {ENG:Content_ENG} {DEU:Content_DEU} - Inhalt
 ════════════════════════════════════════════
 Inhalt ▄
  ▀▀▀▀▀▀▀
Die Programmiersprache PASCAL wurde 1970 durch
Niklaus Wirth an der ETH Zürich entwickelt.
Sie wurde als eine Sprache entworfen, die zur
Ausbildung von Programmiererinnen und Programmiererinnen
geeignet ist. Die Sprache ist einfach und klar
strukturiert und so konzipiert, dass sie auf
"kleinen" Computern eingesetzt werden kann.
Namensgeber für die Sprache PASCAL war der französische
Mathematiker Blaise Pascal, der im Jahr 1652 einen
der ersten mechanischen Rechenautomaten erfunden hat.

Seit 1985 gab es auf DOS-Rechnern den Sprachstandard
Turbo-Pascal 3.0, der in den Folgejahren über die Versionen
4 - 5.5 - 6 - 7 ständig weiter entwickelt wurde.
Die Windows-Variante von PASCAL ist DELPHI und sie erfreut
sich heute zunehmender Beliebtheit.

Das Ziel bei der Entwicklung war es, eine Sprache zu erfinden,
die:
 » auf wenigen, grundlegenden Konzepten aufbauend
 » einfache, übersichtliche Sprachkonstruktionen und
 » einfache sprachliche Regeln (Syntax) aufweist und
 » mit einem einfachen Compiler effizienten Code erzeugt

Die einfachsten Programme bestehen im wesentlichen aus
einem  Eingabeteil, einem Verarbeitungsteil und einem 
Ausgabeteil (EVA-Prinzip).
Die einzelnen Teile werden der Reihe nach ausgeführt.
Eine solche Aneinanderreihung von Anweisungen heißt Sequenz.

{Pascal-Schlüßelwörter (keywords):keywords_DEU}

; ---------------------------------------------------------------
; german - keywords
; ---------------------------------------------------------------
.topic keywords_DEU
 {ENG:keywords_ENG} {DEU:keywords_DEU} - Schlüßelwörter
 ════════════════════════════════════════════
 Reservierte Codewörter ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
reservierte Pascal-Codewörter:

{array:keywords_array_DEU},
{begin:keywords_begin_DEU},
{boolean:keywords_boolean_DEU},
{break:keywords_break_DEU},
{byte:keywords_byte_DEU},
{case:keywords_case_DEU},
{char:keywords_char_DEU},
{default:keywords_default_DEU},
{do:keywords_do_DEU},
{else:keywords_else_DEU},
{end:keywords_end_DEU},
{for:keywords_for_DEU},
{function:keywords_function_DEU},
{if:keywords_if_DEU},
{integer:keywords_integer_DEU},
{library:keywords_library_DEU},
{of:keywords_of_DEU},
{procedure:keywords_procedure_DEU},
{program:keywords_program_DEU},
{real:keywords_real_DEU},
{repeat:keywords_repeat_DEU},
{sizeof:keywords_sizeof_DEU},
{string:keywords_string_DEU},
{to:keywords_to_DEU},
{unit:keywords_unit_DEU},
{until:keywords_until_DEU},
{var:keywords_var_DEU},
{while:keywords_while_DEU},
{word:keywords_word_DEU}

.topic keywords_array_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - array
 ════════════════════════════════════════════
 array ▄
  ▀▀▀▀▀▀
Ein Array ist vereinfacht gesagt, eine Liste von Werten des
gleichen Datentyps. 

Die genaue Struktur der Array-Deklaration ist:

array [<startindex> .. <endindex>] of <Datentyp>; 

startindex..endindex ist dabei eine so genannte Bereichsstruktur
mit dem man den Bereich zwischen Startwert und Endwert angeben kann
(Randwerte werden mit eingeschlossen).
Es ist auch möglich, einen Bereich wie -3..5 anzugeben

Der Name einer Array-Variablen sollte immer ein Substantiv sein
und in der Mehrzahl stehen.

Auf Arrays zugreifen:
Um nun auf die einzelnen Elemente zuzugreifen, verwendet
man folgende Syntax:

 array_name[1] := 'Axel Folloy';
 array_name[2] := 'Arnold Terminator';
 
Die Zahl in den eckigen Klammern ist der so genannte Index.
Er gibt an, auf welches Element des Arrays wir zugreifen
wollen.
Gültige Werte sind hier die Zahlen 1 bis 2.
Ein weiterer Vorteil von Arrays ist, dass man anstatt eines
festen Indexes auch einen ordinalen Datentyp angeben kann.
Das heißt z.B. eine Integer-Variable.

Die Abfrage der Namen von 10 Gästen ließe sich also sehr so
einfach implementieren: 

 {var:keywords_var_DEU}
   index: {Integer:keywords_integer_DEU};
   gaeste: array[1..10] {of:keywords_of_DEU} {Integer:keywords_string_DEU};
 {begin:keywords_begin_DEU}
   {for:keywords_for_DEU} index := 1 {to:keywords_to_DEU} 10 {do:keywords_do_DEU}
   {begin:keywords_begin_DEU}
     Writeln('Bitte geben Sie den Namen des ', index, '. Gastes ein:');
     Readln(gaeste[index]);
   {end:keywords_end_DEU};
 {end:keywords_end_DEU}.

Dynamische Arrays

Ändern wir unser Szenario so ab, dass wir eine Gästeliste erstellen wollen,
aber nicht wissen, wieviele Gäste diese beinhalten soll.

Nun könnten wir zwar ein Array erzeugen, das auf jeden Fall groß genug
ist um alle Gäste der Welt aufzunehmen.

Allerdings wäre dies eine Verschwendung von Speicher und nicht gerade
effektiv.

Hier kommen uns die dynamischen Arrays zu Hilfe.
Dabei handelt es sich, wie man vielleicht vermuten kann, um Arrays,
deren Länge man zur Laufzeit verändern kann.

Erstellt werden sie praktisch genauso wie normale Arrays,
nur geben wir diesmal keinen Indexbereich an:

 {var:keywords_var_DEU}
   gaeste: array {of:keywords_of_DEU} {string:keywords_string_DEU};
   
Der Indexbereich eines dynamischen Arrays ist zwar dynamisch,
aber er beginnt zwingend immer mit 0.
Zu Beginn hat dieser Array die Länge 0, d.h. er beinhaltet momentan
keine Werte.

Länge des Arrays verändern

Nun verändern wir die Länge des Arrays auf 10: 

 SetLength(gaeste, 10);

Unser Array hat nun eine Länge von 10.
Das bedeutet, wir können 10 Zeichenketten (String's) in ihm
verstauen.
Allerdings hat das höchste Element im Array den Index 9.
Das liegt daran, dass das erste Element den Index 0 hat
und wir daher mit dem Index 9 schon 10 Elemente zusammen
haben.

Nun könnten wir zum Einlesen unserer Gästeliste so vorgehen:

 {var:keywords_var_DEU}
   index, anzahlgaeste: {Integer:keywords_integer_DEU};
   gaeste: array {of:keywords_of_DEU} {string:keywords_string_DEU};
 {begin:keywords_begin_DEU}
   Writeln('Bitte geben Sie die Anzahl der Gäste ein:');
   Readln(anzahlgaeste);
   SetLength(gaeste, anzahlgaeste);
   {for:keywords_for_DEU} index := 0 {to:keywords_to_DEU} anzahlgaeste-1 {do:keywords_do_DEU}
   {begin:keywords_begin_DEU}
     Writeln('Bitte geben Sie den Namen des ', index + 1, '. Gastes ein:');
     Readln(gaeste[index]);
   {end:keywords_end_DEU};
 {end:keywords_end_DEU};

Dies würde zwar zum gewünschten Erfolg führen, allerdings benötigen
wir so ständig eine weitere Variable, die die Länge
unseres Arrays angibt.
Um dies zu umgehen, bedienen wir uns der Routinen High und Low.

Erster und letzter Index:

Die Routine High liefert den höchsten Index des übergeben Arrays zurück:

 SetLength(gaeste, 10);
 Writeln(High(gaeste));

 SetLength(gaeste, 120);
 Writeln(High(gaeste));
 
Die Routine Length gibt, wie sich vermuten lässt, die Länge des Arrays zurück:

 SetLength(gaeste, 10);
 Writeln(Length(gaeste));

Mehrdimensionale Arrays

Bis jetzt haben wir uns nur mit eindimensionalen Arrays beschäftigt.
Wir haben in Pascal aber auch die Möglichkeit, mehrdimensionale Arrays
anzulegen.

Dabei kann jeder Unterbereich mit einem festen oder dynamischen
Indexbereich versehen sein. Ein mehrdimensionales Array kann man sich
wie eine Tabelle vorstellen, was bei zwei und drei Indexbereichen
noch nicht schwerfallen dürfte, Pascal erlaubt aber auch weitere
Dimensionen darüber hinaus.

Bei einem zweidimensionalen Array kann zum Beispiel in Gedanken der
erste Bereich für eine Zeile und der zweite Bereich für eine Spalte
in dieser Zeile stehen.

Das einfachste sind wiederum mehrdimensionale statische Arrays mit festen
Indexbereichen.
Die einzelnen Bereiche werden mit Kommata voneinander getrennt.

 {var:keywords_var_DEU}
   a1: array[1..10, 0..5] {of:keywords_of_DEU} {Byte:keywords_byte_DEU};
   a2: array[1..10, 1..10, 1..10] {of:keywords_of_DEU} {Byte:keywords_byte_DEU};

 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_begin_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - begin
 ════════════════════════════════════════════
 begin ▄
  ▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_boolean_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - boolean
 ════════════════════════════════════════════
 boolean ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_break_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - break
 ════════════════════════════════════════════
 break ▄
  ▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_byte_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - byte
 ════════════════════════════════════════════
 byte ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_case_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - case
 ════════════════════════════════════════════
 case ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_char_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - char
 ════════════════════════════════════════════
 char ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_default_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - default
 ════════════════════════════════════════════
 default ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_do_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - do
 ════════════════════════════════════════════
 do ▄
  ▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_else_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - else
 ════════════════════════════════════════════
 else ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_end_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - end
 ════════════════════════════════════════════
 end ▄
  ▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_for_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - for
 ════════════════════════════════════════════
 for ▄
  ▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_function_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - function
 ════════════════════════════════════════════
 function ▄
  ▀▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_if_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - if
 ════════════════════════════════════════════
 if ▄
  ▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_integer_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - integer
 ════════════════════════════════════════════
 integer ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_library_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - library
 ════════════════════════════════════════════
 library ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_of_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - of
 ════════════════════════════════════════════
 of ▄
  ▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_procedure_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - procedure
 ════════════════════════════════════════════
 procedure ▄
  ▀▀▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_program_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - program
 ════════════════════════════════════════════
 program ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_real_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - real
 ════════════════════════════════════════════
 real ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_repeat_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - repeat
 ════════════════════════════════════════════
 repeat ▄
  ▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_sizeof_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - sizeof
 ════════════════════════════════════════════
 sizeof ▄
  ▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_string_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - string
 ════════════════════════════════════════════
 string ▄
  ▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_to_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - to
 ════════════════════════════════════════════
 to ▄
  ▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_unit_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - unit
 ════════════════════════════════════════════
 unit ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_until_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - until
 ════════════════════════════════════════════
 until ▄
  ▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_var_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - var
 ════════════════════════════════════════════
 var ▄
  ▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_while_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - while
 ════════════════════════════════════════════
 while ▄
  ▀▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

.topic keywords_word_DEU
 {Content:Content_ENG} {Schlüßelwörter:keywords_DEU} - word
 ════════════════════════════════════════════
 word ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {ENG:keywords_ENG} {Inhalt:Content_DEU}

; ---------------------------------------------------------------
; english - keywords
; ---------------------------------------------------------------
.topic keywords_ENG
 {Content:Content_ENG} {DEU:keywords_DEU} - keywords
 ════════════════════════════════════════════
 Reserved keywords ▄
  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
reserved Pascal-keywords:

{array:keywords_array_ENG},
{begin:keywords_begin_ENG},
{boolean:keywords_boolean_ENG},
{break:keywords_break_ENG},
{byte:keywords_byte_ENG},
{case:keywords_case_ENG},
{char:keywords_char_ENG},
{default:keywords_default_ENG},
{do:keywords_do_ENG},
{else:keywords_else_ENG},
{end:keywords_end_ENG},
{for:keywords_for_ENG},
{function:keywords_function_ENG},
{if:keywords_if_ENG},
{integer:keywords_integer_ENG},
{library:keywords_library_ENG},
{of:keywords_of_ENG},
{procedure:keywords_procedure_ENG},
{program:keywords_program_ENG},
{real:keywords_real_ENG},
{repeat:keywords_repeat_ENG},
{sizeof:keywords_sizeof_ENG},
{string:keywords_string_ENG},
{to:keywords_to_ENG},
{unit:keywords_unit_ENG},
{until:keywords_until_ENG},
{var:keywords_var_ENG},
{while:keywords_while_ENG},
{word:keywords_word_ENG}

.topic keywords_array_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - array
 ════════════════════════════════════════════
 array ▄
  ▀▀▀▀▀▀
In simple terms, an array is a list of values of the same
data type.

The exact structure of the array declaration is:

array [<startindex> .. <endindex>] of <Datatype>; 

startindex..endindex is a so called range structure
which we can specify the range between startindex and endindex
(boundary values are allowed).

The name of an array variable should always be a noun and should
be in plural.

Accessing arrays:
To access the individual elements, use the following syntax:

 array_name[1] := 'Axel Folloy';
 array_name[2] := 'Arnold Terminator';

The number in the square brackets is the so-called index.
It indicates which element of the array we want to access.
Valid values here are the numbers 1 to 2.
Another advantage of arrays is that you can specify an ordinal data type
with fixed index. That is, for example, an integer variable.

To query the names of 10 guests could be simply implemented as follows

 {var:keywords_var_ENG}
   index: {Integer:keywords_integer_ENG};
   guests: array[1..10] {of:keywords_of_ENG} {Integer:keywords_string_ENG};
 {begin:keywords_begin_ENG}
   {for:keywords_for_ENG} index := 1 {to:keywords_to_ENG} 10 {do:keywords_do_ENG}
   {begin:keywords_begin_ENG}
     Writeln('please type-in the guest name of index: ', index);
     Readln(guests[index]);
   {end:keywords_end_ENG};
 {end:keywords_end_ENG}.

Dynamic arrays

Let's change our scenario so that we want to create a guest list,
but we don't know how many guests it should contain.

Now we could create an array that is big enough to hold all the
Guests on the Planet Earth.

But, this would be a waste of memory and not very effective.

In this context, dynamic arrays come to our aid.
These are, as you might guess, arrays, which can be changed
in length at runtime.

They are created practically in the same way as normal arrays,
except at this time we do not specify an index range:

 {var:keywords_var_ENG}
   gaeste: array {of:keywords_of_ENG} {string:keywords_string_ENG};

The index range of a dynamic array is dynamic,
but it always starts at index value 0.
At the start of the array, it has the length 0, i.e. it currently contains
no values.


Change the length of the array

Now we change the length of the array to 10 elements

 SetLength(gaeste, 10);

Now, our array has a space enough for 10 elements.
That means we can store 10 strings in it.

The highest element in the array has index 9.
This is, because the first element has the index 0 and therefore
with index 9 we already have 10 elements together.

To read in our guest list we could proceed like this, now:

 {var:keywords_var_ENG}
   index, numberguests: {Integer:keywords_integer_ENG};
   guests: array {of:keywords_of_ENG} {string:keywords_string_ENG};
 {begin:keywords_begin_ENG}
   Writeln('please enter the number of guests:');
   Readln(numberguests);
   SetLength(gaeste, numberguests);
   {for:keywords_for_ENG} index := 0 {to:keywords_to_ENG} numberguests-1 {do:keywords_do_ENG}
   {begin:keywords_begin_ENG}
     Writeln('please enter the name of guest: ', index + 1, ':');
     Readln(guests[index]);
   {end:keywords_end_ENG};
 {end:keywords_end_ENG};

This would lead to the desired success, but this way we constantly need
another variable that specifies the length of our array.
To get around this, we use the High and Low routines.

First and last index

The routine High returns the highest index of the passed array:

 SetLength(gaeste, 10);
 Writeln(High(gaeste));

 SetLength(gaeste, 120);
 Writeln(High(gaeste));
 
The Length routine returns, as you might guess, the length of the array

Multi-dimensional arrays

Until now we have only dealt with one-dimensional arrays.
But in Pascal we also have the possibility to create multidimensional arrays.

Each subarea can be provided with a fixed or dynamic index range.
A multidimensional array can be think as a table, which should not be
difficult by two or three index areas.
Pascal also allows further dimensions beyond.

For a two-dimensional array, the first range stands for a row, and the second
range for a column in this row.

The simplest variant of multidimensional arrays are static arrays with fixed
index ranges.
The individual areas are separated from each other with commas.

 {var:keywords_var_DEU}
   a1: array[1..10, 0..5] {of:keywords_of_DEU} {Byte:keywords_byte_DEU};
   a2: array[1..10, 1..10, 1..10] {of:keywords_of_DEU} {Byte:keywords_byte_DEU};


 ════════════════════════════════════════════
 {DEU:keywords_array_DEU} {Content:Content_ENG}

.topic keywords_begin_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - begin
 ════════════════════════════════════════════
 begin ▄
  ▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_begin_DEU} {Content:Content_ENG}

.topic keywords_boolean_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - boolean
 ════════════════════════════════════════════
 boolean ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_boolean_DEU} {Content:Content_ENG}

.topic keywords_break_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - break
 ════════════════════════════════════════════
 break ▄
  ▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_break_DEU} {Content:Content_ENG}

.topic keywords_byte_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - byte
 ════════════════════════════════════════════
 byte ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_byte_DEU} {Content:Content_ENG}

.topic keywords_case_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - case
 ════════════════════════════════════════════
 case ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_case_DEU} {Content:Content_ENG}

.topic keywords_char_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - char
 ════════════════════════════════════════════
 char ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_char_DEU} {Content:Content_ENG}

.topic keywords_default_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - default
 ════════════════════════════════════════════
 default ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_default_DEU} {Content:Content_ENG}

.topic keywords_do_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - do
 ════════════════════════════════════════════
 do ▄
  ▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_do_DEU} {Content:Content_ENG}

.topic keywords_else_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - else
 ════════════════════════════════════════════
 else ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_else_DEU} {Content:Content_ENG}

.topic keywords_end_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - end
 ════════════════════════════════════════════
 end ▄
  ▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_end_DEU} {Content:Content_ENG}

.topic keywords_for_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - for
 ════════════════════════════════════════════
 for ▄
  ▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_for_DEU} {Content:Content_ENG}

.topic keywords_function_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - function
 ════════════════════════════════════════════
 function ▄
  ▀▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_function_DEU} {Content:Content_ENG}

.topic keywords_if_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - if
 ════════════════════════════════════════════
 if ▄
  ▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_if_DEU} {Content:Content_ENG}

.topic keywords_integer_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - integer
 ════════════════════════════════════════════
 integer ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_integer_DEU} {Content:Content_ENG}

.topic keywords_library_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - library
 ════════════════════════════════════════════
 library ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_library_DEU} {Content:Content_ENG}

.topic keywords_of_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - of
 ════════════════════════════════════════════
 of ▄
  ▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_of_DEU} {Content:Content_ENG}

.topic keywords_procedure_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - procedure
 ════════════════════════════════════════════
 procedure ▄
  ▀▀▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_procedure_DEU} {Content:Content_ENG}

.topic keywords_program_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - program
 ════════════════════════════════════════════
 program ▄
  ▀▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_program_DEU} {Content:Content_ENG}

.topic keywords_real_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - real
 ════════════════════════════════════════════
 real ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_real_DEU} {Content:Content_ENG}

.topic keywords_repeat_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - repeat
 ════════════════════════════════════════════
 repeat ▄
  ▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_repeat_DEU} {Content:Content_ENG}
 
.topic keywords_sizeof_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - sizeof
 ════════════════════════════════════════════
 sizeof ▄
  ▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_sizeof_DEU} {Content:Content_ENG}

.topic keywords_string_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - string
 ════════════════════════════════════════════
 string ▄
  ▀▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_string_DEU} {Content:Content_ENG}

.topic keywords_to_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - to
 ════════════════════════════════════════════
 to ▄
  ▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_to_DEU} {Content:Content_ENG}

.topic keywords_unit_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - unit
 ════════════════════════════════════════════
 unit ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_unit_DEU} {Content:Content_ENG}

.topic keywords_until_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - until
 ════════════════════════════════════════════
 until ▄
  ▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_until_DEU} {Content:Content_ENG}

.topic keywords_var_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - var
 ════════════════════════════════════════════
 var ▄
  ▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_var_DEU} {Content:Content_ENG}

.topic keywords_while_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - while
 ════════════════════════════════════════════
 while ▄
  ▀▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_while_DEU} {Content:Content_ENG}

.topic keywords_word_ENG
 {Content:Content_ENG} {keywords:keywords_ENG} - word
 ════════════════════════════════════════════
 word ▄
  ▀▀▀▀▀
 ════════════════════════════════════════════
 {DEU:keywords_word_DEU} {Content:Content_ENG}


; ---------------------------------------------------
; dBase help contexts - english
; ---------------------------------------------------
.topic DBASE_Content_ENG
 {DEU:DBASE_Content_DEU} - Content
 ════════════════════════════════════════════
 {Data:DBASE_list_data_ENG},
 {Queries:DBASE_list_queries_ENG},
 {Forms:DBASE_list_forms_ENG},
 {Reports:DBASE_list_reports_ENG},
 {Labels:DBASE_list_labels_ENG},
 {Applications:DBASE_list_applications_ENG}

.topic DBASE_list_data_ENG
 {DEU:DBASE_list_data_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
 <create: Data>

Here, you have a list of available Data Tables in the current
dBase-Catalog.
To modified the table file, press: Enter / Return.

You can use the UP-, and DOWN-Key to scroll up or down.
Press Tabulator-Key to change the input type list.


.topic DBASE_list_queries_ENG
 {DEU:DBASE_list_queries_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
 <create: Queries>
 
Here, you have a list of available Queries in the current
dBase-Catalog.
To modified the query file, press: Enter / Return.

You can use the UP-, and DOWN-Key to scroll up or down.
Press Tabulator-Key to change the input type list.

.topic DBASE_list_forms_ENG
 {DEU:DBASE_list_forms_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
 <create: Forms>

Here, you have a list of available Form's in the current
dBase-Catalog.
To modified the form file, press: Enter / Return.

You can use the UP-, and DOWN-Key to scroll up or down.
Press Tabulator-Key to change the input type list.

.topic DBASE_list_reports_ENG
 {DEU:DBASE_list_reports_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
 <create: Reports>
 
Here, you have a list of available Report's in the current
dBase-Catalog.
To modified the report file, press: Enter / Return.

You can use the UP-, and DOWN-Key to scroll up or down.
Press Tabulator-Key to change the input type list.

.topic DBASE_list_labels_ENG
 {DEU:DBASE_list_labels_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
 <create: Labels>

Here, you have a list of available Label's in the current
dBase-Catalog.
To modified the label file, press: Enter / Return.

You can use the UP-, and DOWN-Key to scroll up or down.
Press Tabulator-Key to change the input type list.

.topic DBASE_list_applications_ENG
 {DEU:DBASE_list_applications_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
 <create: Applications>
 
Here, you have a list of available Application's in the current
dBase-Catalog.
To modified the application file, press: Enter / Return.

You can use the UP-, and DOWN-Key to scroll up or down.
Press Tabulator-Key to change the input type list.

.topic DBASE_data_field_wind_ENG
 {DEU:DBASE_data_field_wind_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
Table-Field-Editor Window

.topic DBASE_data_field_name_ENG
 {DEU:DBASE_data_field_name_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
Field-name

.topic DBASE_data_field_type_ENG
 {DEU:DBASE_data_field_type_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
Field-type

.topic DBASE_data_field_leng_ENG
 {DEU:DBASE_data_field_leng_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
Field-length

.topic DBASE_data_field_prec_ENG
 {DEU:DBASE_data_field_prec_DEU} {Content:DBASE_Content_ENG}
 ════════════════════════════════════════════
field-precission

; ---------------------------------------------------
; dBase help contexts - german
; ---------------------------------------------------
.topic DBASE_Content_DEU
 {ENG:DBASE_Content_ENG} - Inhalt
 ════════════════════════════════════════════
 {Tabellen:DBASE_list_data_DEU},
 {Abfragen:DBASE_list_queries_DEU},
 {Formulare:DBASE_list_forms_DEU},
 {Reporte:DBASE_list_reports_DEU},
 {Ettiketten:DBASE_list_labels_DEU},
 {Applications:DBASE_list_applications_DEU}

.topic DBASE_list_data_DEU
 {ENG:DBASE_list_data_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
 <create: Tabellen>
 
Hier können sie die Tabellen sehen, die im aktuellen
Catalog zur verfügung stehen.
Zum bearbeiten, drücken Sie die Eingabe-Taste (Return / Enter).

Sie können die Auf-, und Ab-Cursor Taste zum navigieren nutzen.
Drücken Sie die Tabulator-Taste, um in den nächsten Listen-Inhalt zu wechseln.

.topic DBASE_list_queries_DEU
 {ENG:DBASE_list_queries_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
 <create: Abfragen>

Hier können sie die Abfragen sehen, die im aktuellen
Catalog zur verfügung stehen.
Zum bearbeiten, drücken Sie die Eingabe-Taste (Return / Enter).

Sie können die Auf-, und Ab-Cursor Taste zum navigieren nutzen.
Drücken Sie die Tabulator-Taste, um in den nächsten Listen-Inhalt zu wechseln.

.topic DBASE_list_forms_DEU
 {ENG:DBASE_list_forms_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
 <create: Formulare>
 
Hier können sie die Formulare sehen, die im aktuellen
Catalog zur verfügung stehen.
Zum bearbeiten, drücken Sie die Eingabe-Taste (Return / Enter).

Sie können die Auf-, und Ab-Cursor Taste zum navigieren nutzen.
Drücken Sie die Tabulator-Taste, um in den nächsten Listen-Inhalt zu wechseln.

.topic DBASE_list_reports_DEU
 {ENG:DBASE_list_reports_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
 <create: Reporte>

Hier können sie die Reporte sehen, die im aktuellen
Catalog zur verfügung stehen.
Zum bearbeiten, drücken Sie die Eingabe-Taste (Return / Enter).

Sie können die Auf-, und Ab-Cursor Taste zum navigieren nutzen.
Drücken Sie die Tabulator-Taste, um in den nächsten Listen-Inhalt zu wechseln.

.topic DBASE_list_labels_DEU
 {ENG:DBASE_list_labels_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
 <create: Ettiketten>

Hier können sie die Ettiketen sehen, die im aktuellen
Catalog zur verfügung stehen.
Zum bearbeiten, drücken Sie die Eingabe-Taste (Return / Enter).

Sie können die Auf-, und Ab-Cursor Taste zum navigieren nutzen.
Drücken Sie die Tabulator-Taste, um in den nächsten Listen-Inhalt zu wechseln.

.topic DBASE_list_applications_DEU
 {ENG:DBASE_list_applications_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
 <create: Programme>

Hier können sie die Programme sehen, die im aktuellen
Catalog zur verfügung stehen.
Zum bearbeiten, drücken Sie die Eingabe-Taste (Return / Enter).

Sie können die Auf-, und Ab-Cursor Taste zum navigieren nutzen.
Drücken Sie die Tabulator-Taste, um in den nächsten Listen-Inhalt zu wechseln.

; ---------------------------------------------------
; dBase help contexts for new table data - german
; ---------------------------------------------------
.topic DBASE_data_field_wind_DEU
 {DEU:DBASE_data_field_wind_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
Tabellen-Feld-Editor Fenster

.topic DBASE_data_field_name_DEU
 {ENG:DBASE_data_field_name_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
Feld-Name

.topic DBASE_data_field_type_DEU
 {ENG:DBASE_data_field_type_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
Feld-Typ

.topic DBASE_data_field_leng_DEU
 {ENG:DBASE_data_field_leng_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
Feld- Länge

.topic DBASE_data_field_prec_DEU
 {ENG:DBASE_data_field_prec_ENG} {Inhalt:DBASE_Content_DEU}
 ════════════════════════════════════════════
Feld-Präzission

; Assembler keywords - english
.topic ASM_Content_ENG
 {DEU:ASM_Content_DEU} - Assembler Content
 ════════════════════════════════════════════
Here, you can find the supported assembler keywords for
assembler Project's:

{aaa:ASM_Content_aaa_ENG},
{aad:ASM_Content_aad_ENG},
{aam:ASM_Content_aam_ENG},
{aas:ASM_Content_aas_ENG},
{aac:ASM_Content_aac_ENG},
{add:ASM_Content_aad_ENG},
{and:ASM_Content_and_DEU},

{mov:ASM_Content_mov_ENG}

.topic ASM_Content_aaa_ENG
 {DEU:ASM_Content_aaa_DEU} {keywords:ASM_Content_ENG} - aaa
 ════════════════════════════════════════════
 aaa ▄
  ▀▀▀▀
Adjust Result for ASCII-Addition

 ════════════════════════════════════════════
 {DEU:ASM_Content_DEU} {Content:ASM_Content_ENG}

.topic ASM_Content_aad_ENG
 {ENG:ASM_Content_aad_ENG} {keywords:ASM_Content_ENG} - aad
 ════════════════════════════════════════════
 aad ▄
  ▀▀▀▀
Adjust Result for ASCII-Addition

 ════════════════════════════════════════════
 {DEU:ASM_Content_aad_DEU} {Content:ASM_Content_ENG}

.topic ASM_Content_aam_ENG
.topic ASM_Content_aas_ENG
.topic ASM_Content_aac_ENG
.topic ASM_Content_add_ENG
.topic ASM_Content_and_ENG

.topic ASM_Content_mov_ENG
 {Content:ASM_Content_ENG} {keywords:ASM_Content_ENG} - mov
 ════════════════════════════════════════════
 mov ▄
  ▀▀▀▀
 ════════════════════════════════════════════
 {DEU:ASM_Content_DEU} {Content:ASM_Content_ENG}

; ---------------------------------------------------
; Assembler keywords - german
; ---------------------------------------------------
.topic ASM_Content_DEU
 {DEU:ASM_Content_DEU} - Assembler Inhalt
 ════════════════════════════════════════════
Hier finden Sie eine Liste der unterstützten Assembler-Befehle:

{aaa:ASM_Content_aaa_DEU},
{aad:ASM_Content_aad_DEU},
{aam:ASM_Content_aam_DEU},
{aas:ASM_Content_aas_DEU},
{aac:ASM_Content_aac_DEU},
{add:ASM_Content_aad_DEU},
{and:ASM_Content_and_DEU},

{mov:ASM_Content_mov_DEU}

.topic ASM_Content_aaa_DEU
 {ENG:ASM_Content_aaa_ENG} {Schlüsselwörter:ASM_Content_DEU} - aaa
 ════════════════════════════════════════════
 aaa ▄
  ▀▀▀▀
Adjust Result for ASCII-Addition
=> ASCII-Anpassung nach einer Addition

Beschreibung:

AAA wandelt das AL-Register in eine ungepackte BCD-Zahl um. Sofern die vier unteren Bits von AL kleiner gleich 9 sind, werden die vier
oberen Bits auf Null gesetzt und die Flags AF und CF gelöscht. Falls die unteren vier Bits eine ungültige BCD-Zahl (Pseudotetrade)
darstellen oder das Halfcarry-Flag (A) gesetzt ist, wird 6 zum AL-Register addiert, AH um eins erhöht, um den Überlauf anzuzeigen, und die
vier oberen Bits von AL werden gelöscht. Damit enthält das AX-Register eine 2-stellige BCD Zahl (höherwertiger Teil in AH,
niederwertiger Teil in AL).

Beispiel:
Aus AL = 0x0F (hex) wird AX = 0x0105 (=15 BCD)

 ════════════════════════════════════════════
 {ENG:ASM_Content_aaa_ENG} {ASM-Inhalt:ASM_Content_DEU}

.topic ASM_Content_aad_DEU
 {ENG:ASM_Content_aad_ENG} {Schlüsselwörter:ASM_Content_DEU} - aad
 ════════════════════════════════════════════
 aad ▄
  ▀▀▀▀
Adjust Register for Division.
=> ASCII-Anpassung für die Division.

Beschreibung:
AAD wandelt eine zweistellige ungepackte BCD-Zahl im AX-Register (höherwertiger Teil in AH, niederwertiger Teil in AL) in die
entsprechende Dualzahl um. Dies ist z.B. zur Vorbereitung einer korrekten BCD-Division nötig.

Beispiel:
Aus AX = 0x0105 (=15 BCD) wird AX = 0x000F(hex)

 ════════════════════════════════════════════
 {ENG:ASM_Content_aad_ENG} {ASM-Inhalt:ASM_Content_DEU}

.topic ASM_Content_aam_DEU
 {ENG:ASM_Content_aam_ENG} {Schlüsselwörter:ASM_Content_DEU} - aam
 ════════════════════════════════════════════
 aam ▄
  ▀▀▀▀
Adjust Result of BCD-Multiplication.
=> ASCII-Anpassung für die Multiplikation.

Beschreibung:
AAM wandelt nach einer Multiplikation der Register AL und AH, sofern in beiden Registern eine ungepackte BCD-Zahl stand, das Ergebnis
in eine gültige ungepackte BCD-Zahl im AX-Register um.

 Beispiel:
 AX = 0x0909h (=99 BCD)
 MUL AH,AL (=51 hex)
 AAM - > AX = 0x0801 (=81 BCD)

 ════════════════════════════════════════════
 {ENG:ASM_Content_aad_ENG} {ASM-Inhalt:ASM_Content_DEU}

.topic ASM_Content_aas_DEU
 {ENG:ASM_Content_aas_ENG} {Schlüsselwörter:ASM_Content_DEU} - aad
 ════════════════════════════════════════════
 aas ▄
  ▀▀▀▀
 Adjust Result for ASCII-Subtraction.
 => ASCII-Anpassung für die Subtraktion.

 Beschreibung:
 AAS wandelt die Zahl im AL-Register (z.B. das Ergebnis nach einer Subtraktion) in eine BCD-Zahl um. Sofern die Zahl in AL größer als 9
 ist (ungültige ungepackte BCD-Zahl), wird 6 vom AL- und 1 vom AH-Register subtrahiert und die Flags C und A gesetzt, ansonsten werden
 diese Flags gelöscht. Die höherwertigen 4 Bits im AL-Register werden in jedem Fall gelöscht. Als Ergebnis bleibt eine 4-Bit BCD-Zahl im
 AL-Register.

 ════════════════════════════════════════════
 {ENG:ASM_Content_aas_ENG} {ASM-Inhalt:ASM_Content_DEU}

.topic ASM_Content_aac_DEU
 {ENG:ASM_Content_aac_ENG} {Schlüsselwörter:ASM_Content_DEU} - aad
 ════════════════════════════════════════════
 aac ▄
  ▀▀▀▀
 Add with Carry-Flag
 => Addieren mit Übertrag

Syntax: ADC <Zieloperand>,<Quelloperand>

 Beschreibung:
 ADC addiert den Quelloperanden zum Zieloperanden unter Berücksichtigung des Carry-Flags, so dass ein Überlauf beachtet werden kann.
 Das Ergebnis wird im Zieloperanden abgelegt. Es können 8- und 16-Bit Operanden verarbeitet werden.

 Beispiel:
 STC ; Carry-Flag setzen
 MOV AL, 0x01 ; AL = 1
 MOV AH, 0x01 ; AH = 1
 ADC AL, AH   ; AL = AH + AL + C - > 03

 Operanden                Beispiel: ADC...
 ----------------------------------------------------------
 <Register>, <Register>   AL, BL
 <Register>, <Speicher>   AL, [200]        oder AL,Quelle
 <Speicher>, <Register>   [200], AL        oder Quelle,AL
 <Register>, <Konstante>  AL, 07
 <Speicher>, <Konstante>  byte ptr [200],7 oder Quelle,07
 
 ════════════════════════════════════════════
 {ENG:ASM_Content_aac_ENG} {ASM-Inhalt:ASM_Content_DEU}

.topic ASM_Content_add_DEU
 {ENG:ASM_Content_add_ENG} {Schlüsselwörter:ASM_Content_DEU} - add
 ════════════════════════════════════════════
 add ▄
  ▀▀▀▀
 Addieren (ohne Carry-Flag)

 Syntax: ADD <Zieloperand>,<Quelloperand>
 
 Beschreibung:
 Addiert den Quelloperanden zum Zieloperanden. Das Ergebnis wird im Zieloperanden gespeichert. Ein eventueller Überlauf wird durch das
 Carry-Flag signalisiert, dieses wird aber nicht wie bei ADC in die Addition einbezogen. Es können sowohl 8- als auch 16-Bit Operanden
 verarbeitet werden.

 Operanden                Beispiel: ADD...
 ---------------------------------------------------------------
 <Register>, <Register>   AX,    BX
 <Register>, <Speicher>   AL,    [200]         oder AL, Quelle
 <Speicher>, <Register>   [200], AL            oder Quelle, AL
 <Register>, <Konstante>  AL,    0ff           oder AL, 0ffh
 <Speicher>, <Konstante>  byte   ptr [200], 0a oder Quelle, 0ah
 
 ════════════════════════════════════════════
 {ENG:ASM_Content_aas_ENG} {ASM-Inhalt:ASM_Content_DEU}

.topic ASM_Content_and_DEU
 {ENG:ASM_Content_and_ENG} {Schlüsselwörter:ASM_Content_DEU} - add
 ════════════════════════════════════════════
 and ▄
  ▀▀▀▀
 Und-Verknüpfung

 Syntax: AND <Zieloperand>, <Quelloperand>
 
 Beschreibung:
 Der Zieloperand wird bitweise mit dem Quelloperanden nach der Und-Wahrheitstabelle verknüpft, das Ergebnis befindet sich danach im
 Zieloperanden.
 
 Wahrheitstabelle der UND-Verknüpfung:
 
 Eingang 1 | Eingang 2 | Ausgang
 ----------+-----------+---------
      0    |     0     |    0
      0    |     1     |    0
      1    |     0     |    0
      1    |     1     |    1
	   
 Operanden              Beispiel: AND...
 -------------------------------------------------------------
 <Register>, <Register>  AL,    BL
 <Register>, <Speicher>  AL,    [300]       oder AL, Quelle
 <Speicher>, <Register>  [300], AL          oder Quelle, AL
 <Register>, <Konstante> AL,    07
 <Speicher>, <Konstante> byte ptr [300], 07 oder Quelle, 07

 ════════════════════════════════════════════
 {ENG:ASM_Content_and_ENG} {ASM-Inhalt:ASM_Content_DEU}
 
.topic ASM_Content_mov_DEU
 {ENG:ASM_Content_mov_ENG} {Schlüsselwörter:ASM_Content_DEU} - mov
 ════════════════════════════════════════════
 mov ▄
  ▀▀▀▀
 ════════════════════════════════════════════
 {ENG:ASM_Content_mov_ENG} {ASM-Inhalt:ASM_Content_DEU}


; -------------------------------------------------------------------------
; win32api
; english
; -------------------------------------------------------------------------
.topic win32api_ENG
 win32api:
 ---------

 => Window functions:
 {Creating a Main Window:win32api_CreatingaMainWindow_ENG}
 {Creating, Enumerating, and Sizing Child Windows:win32api_CreatingChildWindows_ENG}
 {Destroying a Window:win32api_DestroyingaWindow_ENG}
 {Using Layered Windows:win32api_UsingLayeredWindows_ENG}

 {CreateWindowExA:win32api_CreateWindowEx_ENG}

 => Controls
 {Creating Common Controls:win32api_CreatingCommonControls_ENG}
 
 => Color: 
 {Color Macros:win32api_ColorMacros_ENG}
 {Colors Overview:win32api_ColorsOverview_ENG}
 
 {GetBValue:win32api_GetBValue_ENG}
 {GetGValue:win32api_GetGValue_ENG}
 {GetRValue:win32api_GetRValue_ENG}
 
 SetTextColor
 
 => Color macros:
 {COLORREF:win32api_COLORREF_ENG}
 {RGB:win32api_RGB_ENG}
 
 => Color functions:
 {SetBkColor:win32api_SetBkColor_ENG}
 
 
 {HDC:win32api_HDC_ENG}

; -------------------------------------------------------------------------
.topic win32api_CreatingaMainWindow_ENG
 Creating a Main Window
 ----------------------
 
 The first window an application creates is typically the main
 window. You create the main window by using the CreateWindowEx
 function, specifying the window class, window name, window styles,
 size, position, menu handle, instance handle, and creation data.
 A main window belongs to an application-defined window class, so
 you must register the window class and provide a window procedure
 for the class before creating the main window.
 
 Most applications typically use the WS_OVERLAPPEDWINDOW style to
 create the main window. This style gives the window a title bar,
 a window menu, a sizing border, and minimize and maximize buttons.
 The CreateWindowEx function returns a handle that uniquely
 identifies the window.
 
 The following example creates a main window belonging to an
 application-defined window class. The window name, Main Window,
 will appear in the window's title bar.
 By combining the WS_VSCROLL and WS_HSCROLL styles with the
 WS_OVERLAPPEDWINDOW style, the application creates a main window
 with horizontal and vertical scroll bars in addition to the
 components provided by the WS_OVERLAPPEDWINDOW style. The four
 occurrences of the CW_USEDEFAULT constant set the initial size and
 position of the window to the system-defined default values.
 By specifying NULL instead of a menu handle, the window will have
 the menu defined for the window class.
 
 Example (C++):
 --------------
 HINSTANCE hinst; 
 HWND hwndMain; 
 
 // Create the main window. 
 hwndMain = CreateWindowEx( 
    0,                      // no extended styles           
    "MainWClass",           // class name                   
    "Main Window",          // window name                  
    WS_OVERLAPPEDWINDOW |   // overlapped window            
             WS_HSCROLL |   // horizontal scroll bar        
             WS_VSCROLL,    // vertical scroll bar          
    CW_USEDEFAULT,          // default horizontal position  
    CW_USEDEFAULT,          // default vertical position    
    CW_USEDEFAULT,          // default width                
    CW_USEDEFAULT,          // default height               
    (HWND) NULL,            // no parent or owner window    
    (HMENU) NULL,           // class menu used              
    hinst,                  // instance handle              
    NULL);                  // no window creation data      
 
 if (!hwndMain) 
     return FALSE; 
 
 // Show the window using the flag specified by the program 
 // that started the application, and send the application 
 // a WM_PAINT message. 
 ShowWindow(hwndMain, SW_SHOWDEFAULT); 
 UpdateWindow(hwndMain);

 Notice that the preceding example calls the ShowWindow function
 after creating the main window.
 This is done because the system does not automatically display
 the main window after creating it. By passing the SW_SHOWDEFAULT
 flag to ShowWindow, the application allows the program that
 started the application to set the initial show state of the
 main window. The UpdateWindow function sends the window its
 first WM_PAINT message. 
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; -------------------------------------------------------------------------
.topic win32api_CreatingChildWindows_ENG
 Creating, Enumerating, and Sizing Child Windows
 -----------------------------------------------
 
 You can divide a window's client area into different functional
 areas by using child windows. Creating a child window is like
 creating a main window—you use the CreateWindowEx function.
 To create a window of an application-defined window class, you must
 register the window class and provide a window procedure before
 creating the child window. You must give the child window the
 WS_CHILD style and specify a parent window for the child window
 when you create it.
 
 The following example divides the client area of an application's
 main window into three functional areas by creating three child
 windows of equal size. Each child window is the same height as
 the main window's client area, but each is one-third its width.
 The main window creates the child windows in response to the
 WM_CREATE message, which the main window receives during its own
 window-creation process. Because each child window has the
 WS_BORDER style, each has a thin line border. Also, because the
 WS_VISIBLE style is not specified, each child window is initially
 hidden.
 Notice also that each child window is assigned a child-window
 identifier.
 
 The main window sizes and positions the child windows in response
 to the WM_SIZE message, which the main window receives when its
 size changes. In response to WM_SIZE, the main window retrieves
 the dimensions of its client area by using the GetClientRect
 function and then passes the dimensions to the EnumChildWindows
 function.
 EnumChildWindows passes the handle to each child window, in turn,
 to the application-defined EnumChildProc callback function.
 This function sizes and positions each child window by calling
 the MoveWindow function; the size and position are based on the
 dimensions of the main window's client area and the identifier
 of the child window.
 Afterward, EnumChildProc calls the ShowWindow function to make
 the window visible.
 
 Example (C++):
 --------------
 #define ID_FIRSTCHILD  100 
 #define ID_SECONDCHILD 101 
 #define ID_THIRDCHILD  102 
 
 LONG APIENTRY MainWndProc(
    HWND   hwnd,
	UINT   uMsg,
    WPARAM wParam,
	LPARAM lParam) 
    {{
    RECT rcClient; 
    int i; 
 
    switch(uMsg) 
    {{ 
        case WM_CREATE: // creating main window  
            // Create three invisible child windows. 
            for (i = 0; i < 3; i++) 
            {{ 
                CreateWindowEx(0, 
                    "ChildWClass", 
                    (LPCTSTR) NULL, 
                    WS_CHILD | WS_BORDER, 
                    0,0,0,0, 
                    hwnd, 
                    (HMENU) (int) (ID_FIRSTCHILD + i), 
                    hinst, 
                    NULL); 
            }
            return 0; 
 
        case WM_SIZE:   // main window changed size 
            // Get the dimensions of the main window's client 
            // area, and enumerate the child windows. Pass the 
            // dimensions to the child windows during enumeration. 
            GetClientRect(hwnd, &rcClient); 
            EnumChildWindows(hwnd, EnumChildProc, (LPARAM) &rcClient); 
            return 0; 

        // Process other messages. 
    } 
    return DefWindowProc(hwnd, uMsg, wParam, lParam); 
 } 
 
 BOOL CALLBACK EnumChildProc(
    HWND   hwndChild,
	LPARAM lParam) 
 {{
    LPRECT rcParent; 
    int i, idChild; 
 
    // Retrieve the child-window identifier. Use it to set the 
    // position of the child window. 
 
    idChild = GetWindowLong(hwndChild, GWL_ID); 
 
    if (idChild == ID_FIRSTCHILD) 
        i = 0; 
    else if (idChild == ID_SECONDCHILD) 
        i = 1; 
    else 
        i = 2; 
 
    // Size and position the child window.  
 
    rcParent = (LPRECT) lParam; 
    MoveWindow(hwndChild, 
               (rcParent->right / 3) * i, 
               0, 
               rcParent->right / 3, 
               rcParent->bottom, 
               TRUE); 
 
    // Make sure the child window is visible. 
 
    ShowWindow(hwndChild, SW_SHOW); 
 
    return TRUE;
 }
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_DestroyingaWindow_ENG
 Destroying a Window
 -------------------
 
 You can use the DestroyWindow function to destroy a window.
 Typically, an application sends the WM_CLOSE message before
 destroying a window, giving the window the opportunity to
 prompt the user for confirmation before the window is destroyed.
 A window that includes a window menu automatically receives the
 WM_CLOSE message when the user clicks Close from the window menu.
 If the user confirms that the window should be destroyed, the
 application calls DestroyWindow. The system sends the
 WM_DESTROY message to the window after removing it from the screen.
 In response to WM_DESTROY, the window saves its data and frees any
 resources it allocated. A main window concludes its processing of
 WM_DESTROY by calling the PostQuitMessage function to quit the
 application.
 
 The following example shows how to prompt for user confirmation
 before destroying a window.
 In response to WM_CLOSE, the example displays a dialog box that
 contains Yes, No, and Cancel buttons. If the user clicks Yes,
 DestroyWindow is called; otherwise, the window is not destroyed.
 Because the window being destroyed is a main window, the example
 calls PostQuitMessage in response to WM_DESTROY.
 
 Example:
 --------
 case WM_CLOSE:
    // Create the message box. If the user clicks 
    // the Yes button, destroy the main window. 
    if (MessageBox(hwnd, szConfirm, szAppName, MB_YESNOCANCEL) == IDYES) 
        DestroyWindow(hwndMain); 
    else 
        return 0; 
 
 case WM_DESTROY: 
    // Post the WM_QUIT message to 
    // quit the application terminate. 
    PostQuitMessage(0); 
    return 0;
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; -------------------------------------------------------------------------
.topic win32api_UsingLayeredWindows_ENG
 Using Layered Windows
 ---------------------
 
 To have a dialog box come up as a translucent window, first
 create the dialog as usual. Then, on WM_INITDIALOG, set the
 layered bit of the window's extended style and call
 SetLayeredWindowAttributes with the desired alpha value.
 The code might look like this:
 
 Example:
 --------
 // Set WS_EX_LAYERED on this window 
 SetWindowLong(hwnd, 
    GWL_EXSTYLE, 
    GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);
 
 // Make this window 70% alpha
 SetLayeredWindowAttributes(hwnd, 0, (255 * 70) / 100, LWA_ALPHA);
 
 Note that the third parameter of SetLayeredWindowAttributes is
 a value that ranges from 0 to 255, with 0 making the window
 completely transparent and 255 making it completely opaque.
 This parameter mimics the more versatile BLENDFUNCTION of
 the AlphaBlend function.
 
 To make this window completely opaque again, remove the
 WS_EX_LAYERED bit by calling SetWindowLong and then ask the
 window to repaint. Removing the bit is desired to let the
 system know that it can free up some memory associated with
 layering and redirection. The code might look like this:
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; -------------------------------------------------------------------------
.topic win32api_CreateWindowEx_ENG
 CreateWindowExA
 ---------------
 
 Creates an overlapped, pop-up, or child window with an
 extended window style; otherwise, this function is identical
 to the CreateWindow function. For more information about
 creating a window and for full descriptions of the other
 parameters of CreateWindowEx, see CreateWindow.

 Syntax (C++):
 -------------
 HWND CreateWindowExA(
   [in]           DWORD     dwExStyle,
   [in, optional] LPCSTR    lpClassName,
   [in, optional] LPCSTR    lpWindowName,
   [in]           DWORD     dwStyle,
   [in]           int       X,
   [in]           int       Y,
   [in]           int       nWidth,
   [in]           int       nHeight,
   [in, optional] HWND      hWndParent,
   [in, optional] HMENU     hMenu,
   [in, optional] HINSTANCE hInstance,
   [in, optional] LPVOID    lpParam
 );
 
 Parameters:
 -----------
 [in] dwExStyle => Type: DWORD
 The extended window style of the windowbeing created.
 For a list of possible values, see
 {Extended Window Styles:win32api_ExtendedWindowStyles_ENG}.
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; -------------------------------------------------------------------------
.topic win32api_ExtendedWindowStyles_ENG
 Extended Window Styles
 ----------------------
 
 Constant/value                Description
 --------------------------------------------------------------------
 WS_EX_ACCEPTFILES         =>  The window accepts drag-drop files.
 0x00000010L
 
 WS_EX_APPWINDOW           =>  Forces a top-level window onto the
 0x00040000L                   taskbar when the window is visible. 
 
 WS_EX_CLIENTEDGE          =>  The window has a border with a sunken edge.
 0x00000200L
 
 WS_EX_COMPOSITED          =>  Paints all descendants of a window in
 0x02000000L                   bottom-to-top painting order using
                               double-buffering. Bottom-to-top painting
                               order allows a descendent window to have
                               translucency (alpha) and transparency (color-key)
                               effects, but only if the descendent window also
                               has the WS_EX_TRANSPARENT bit set.
                               Double-buffering allows the window and its
                               descendents to be painted without flicker.
                               This cannot be used if the window has a class
                               style of either CS_OWNDC or CS_CLASSDC.
                               Windows 2000: This style is not supported.

 WS_EX_CONTEXTHELP         =>  The title bar of the window includes a question
 0x00000400L                   mark. When the user clicks the question mark,
                               the cursor changes to a question mark with a pointer.
                               If the user then clicks a child window, the child
                               receives a WM_HELP message.
                               The child window should pass the message to the
                               parent window procedure, which should call the
                               WinHelp function using the HELP_WM_HELP command.
                               The Help application displays a pop-up window that
                               typically contains help for the child window.
                               WS_EX_CONTEXTHELP cannot be used with the
                               WS_MAXIMIZEBOX or WS_MINIMIZEBOX styles.

 WS_EX_CONTROLPARENT       =>
 WS_EX_DLGMODALFRAME       =>
 WS_EX_LAYERED             =>
 WS_EX_LAYOUTRTL           =>
 WS_EX_LEFT                =>
 WS_EX_LEFTSCROLLBAR       =>
 WS_EX_LTRREADING          =>
 WS_EX_MDICHILD            =>
 WS_EX_NOACTIVATE          =>
 WS_EX_NOINHERITLAYOUT     =>
 WS_EX_NOPARENTNOTIFY      =>
 WS_EX_NOREDIRECTIONBITMAP =>
 
 WS_EX_OVERLAPPEDWINDOW    =>
 WS_EX_WINDOWEDGE |
 WS_EX_CLIENTEDGE
 
 WS_EX_PALETTEWINDOW       =>
 WS_EX_WINDOWEDGE |
 WS_EX_TOOLWINDOW |
 WS_EX_TOPMOST
 
 WS_EX_RIGHT               =>
 WS_EX_RIGHTSCROLLBAR      =>
 WS_EX_RTLREADING          =>
 WS_EX_STATICEDGE          =>
 WS_EX_TOOLWINDOW          =>
 WS_EX_TOPMOST             =>
 WS_EX_TRANSPARENT         =>
 WS_EX_WINDOWEDGE          =>
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => winuser.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_CreatingCommonControls_ENG
 Creating Common Controls
 ------------------------
 
 This topic describes how to create a window that belongs
 to a window class defined in the common control library,
 Comctl32.dll.
 
 Most common controls belong to a window class defined in
 the common control DLL. The window class and the corresponding
 window procedure define the properties, appearance, and
 behavior of the control. To ensure that the common control
 DLL is loaded, include the InitCommonControlsEx function
 in your application. You create a common control by specifying
 the name of the window class when calling the CreateWindowEx
 function or by specifying the appropriate class name in a
 dialog box template.
 
 Each type of common control has a set of control styles that
 you can use to vary the appearance and behavior of the control.
 The common control library also includes a set of control
 styles that apply to two or more types of common controls.
 The common control styles are described in the Styles section.
 
 Related topics:
 ---------------
 {About Common Controls:win32api_AboutCommonControls_ENG}
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_AboutCommonControls_ENG
 About Common Controls
 ---------------------
 
 This topic discusses the common controls, a set of windows that
 are implemented by the common control library,
 Comctl32.dll, which is a DLL included with the Windows operating
 system. Like other control windows, a common control is a child
 window that an application uses in conjunction with another
 window to enable interaction with the user.
 
 In this section
 ---------------
 - {Common Control Versions:win32api_CommonControlVersions_ENG}
 - {Creating Common Controls:win32api_CreatingCommonControls_ENG}
 - {Unicode Support for Common Controls:win32api_UnicodeSupportforCommonControls_ENG}
 - {Localization Support for Common Controls:win32api_LocalizationSupportforCommonControls_ENG}
 - {Common Controls FAQ:win32api_CommonControlsFAQ_ENG}
 
 Related topics
 --------------
 General Control Reference
 Windows Controls
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_CommonControlVersions_ENG
 Common Control Versions
 -----------------------
 
 This topic lists the available versions of the Common Control
 library (ComCtl32.dll), describes how to identify the version
 that your application is using, and explains how to target
 your application for a specific version.
 
 This topic contains the following sections.
 
 - {Common Control DLL Versions Numbers:win32api_CommonControlDLLVersionsNumbers_ENG}
 - {Structure Sizes for Different Common Control Versions:win32api_StructureSizesforDifferentCommonControlVersions_ENG}
 - {Using DllGetVersion to Determine the Version Number:win32api_UsingDllGetVersiontoDeterminetheVersionNumber_ENG}
 - Project Versions
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_CommonControlDLLVersionsNumbers_ENG
 Common Control DLL Versions Numbers
 -----------------------------------
 Support for common controls is provided by ComCtl32.dll, which
 all 32-bit and 64-bit versions of Windows include.
 Each successive version of the DLL supports the features and
 API of earlier versions and adds new features.
 
 Because various versions of ComCtl32.dll were distributed with
 Internet Explorer, the version that is active is sometimes different
 from the version that was shipped with the operating system.
 Therefore, your application must directly determine which version
 of ComCtl32.dll is present.
 
 In the common controls reference documentation, many programming
 elements specify a minimum supported DLL version number.
 This version number indicates that the programming element is
 implemented in that version and subsequent versions of the DLL
 unless otherwise specified. If no version number is specified,
 the programming element is implemented in all existing versions
 of the DLL.
 
 The following table outlines the different DLL versions and how
 they were distributed on supported OSes.
 
 ComCtl32.dll
 ------------
 Version     Distribution Platform
 ---------------------------------------
 5.81     => Microsoft Internet Explorer 5.01,
             Microsoft Internet Explorer 5.5, and
             Microsoft Internet Explorer 6
			 
 5.82     => Windows Server 2003, Windows Vista,
             Windows Server 2008, and Windows 7
			 
 6.0      => Windows Server 2003
 6.10     => Windows Vista,
             Windows Server 2008, and
             Windows 7
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; ------------------------------------------------------------------------- 
.topic win32api_StructureSizesforDifferentCommonControlVersions_ENG
 Structure Sizes for Different Common Control Versions
 -----------------------------------------------------
 
 Ongoing enhancements to common controls have resulted in the
 need to extend many of the structures. For this reason, the
 size of the structures has changed between different versions
 of Commctrl.h.
 Because most of the common control structures take a structure
 size as one of the parameters, a message or function can fail
 if the size is not recognized. To remedy this, structure size
 constants have been defined to aid in targeting different
 version of ComCtl32.dll. The following list defines the
 structure size constants.
 
 Structure Size Constant       Definition
 ----------------------------------------------------------------
 HDITEM_V1_SIZE                The size of the HDITEM structure in version 4.0.
 IMAGELISTDRAWPARAMS_V3_SIZE   The size of the IMAGELISTDRAWPARAMS structure in version 5.9.
 
 LVCOLUMN_V1_SIZE              The size of the LVCOLUMN structure in version 4.0.
 LVGROUP_V5_SIZE               The size of the LVGROUP structure in version 6.0.
 LVHITTESTINFO_V1_SIZE         The size of the LVHITTESTINFO structure in version 4.0.
 LVITEM_V1_SIZE                The size of the LVITEM structure in version 4.0.
 LVITEM_V5_SIZE                The size of the LVITEM structure in version 6.0.
 LVTILEINFO_V5_SIZE            The size of the LVTILEINFO structure in version 6.0.
 
 MCHITTESTINFO_V1_SIZE         The size of the MCHITTESTINFO structure in version 4.0.
 
 NMLVCUSTOMDRAW_V3_SIZE        The size of the NMLVCUSTOMDRAW structure in version 4.7.
 NMTTDISPINFO_V1_SIZE          The size of the NMTTDISPINFO structure in version 4.0.
 NMTVCUSTOMDRAW_V3_SIZE        The size of the NMTVCUSTOMDRAW structure in version 4.7.
 
 PROPSHEETHEADER_V1_SIZE       The size of the PROPSHEETHEADER structure in version 4.0.
 
 PROPSHEETPAGE_V1_SIZE         The size of the PROPSHEETPAGE structure in version 4.0.
 REBARBANDINFO_V3_SIZE         The size of the REBARBANDINFO structure in version 4.7.
 REBARBANDINFO_V6_SIZE         The size of the REBARBANDINFO structure in version 6.0.
 
 TTTOOLINFO_V1_SIZE            The size of the TOOLINFO structure in version 4.0.
 TTTOOLINFO_V2_SIZE            The size of the TOOLINFO structure in version 4.7.
 TTTOOLINFO_V3_SIZE            The size of the TOOLINFO structure in version 6.0.
 
 TVINSERTSTRUCT_V1_SIZE        The size of the TVINSERTSTRUCT structure in version 4.0.
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_UsingDllGetVersiontoDeterminetheVersionNumber_ENG
 Using DllGetVersion to Determine the Version Number
 ---------------------------------------------------
 
 The DllGetVersion function can be called by an application to
 determine which DLL version is present on the system.
 
 DllGetVersion returns a DLLVERSIONINFO2 structure.
 In addition to the information provided through DLLVERSIONINFO,
 DLLVERSIONINFO2 also provides the hotfix number that identifies
 the latest installed service pack, which provides a more robust
 way to compare version numbers. Because the first member of
 DLLVERSIONINFO2 is a DLLVERSIONINFO structure, the later
 structure is backward-compatible.
 
 The following sample function GetVersion loads a specified DLL
 and attempts to call its DllGetVersion function.
 If successful, it uses a macro to pack the major and minor
 version numbers from the DLLVERSIONINFO structure into a DWORD
 that is returned to the calling application.
 If the DLL does not export DllGetVersion, the function returns
 zero. You can modify the function to handle the possibility
 that DllGetVersion returns a DLLVERSIONINFO2 structure.
 If so, use the information in that DLLVERSIONINFO2 structure's
 ullVersion member to compare versions, build numbers, and
 service pack releases. The MAKEDLLVERULL macro simplifies the
 task of comparing these values to those in ullVersion.
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_CommonControlsFAQ_ENG
 Common Controls FAQ
 -------------------
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_UnicodeSupportforCommonControls_ENG
 Unicode Support for Common Controls
 ----------------------------------------
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_LocalizationSupportforCommonControls_ENG
 Localization Support for Common Controls
 ----------------------------------------
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
; win32api
; colors ...
; -------------------------------------------------------------------------
.topic win32api_ColorsOverview_ENG
 Color Overview
 --------------
 
 Color is an important element in the pictures and images
 generated by applications. This overview describes how
 applications can manage and use colors with pens,
 brushes, text, or bitmaps.
 
 {About Colors:win32api_AboutColors_ENG}
 {Using Colors:win32api_UsingColors_ENG}
 {Color Reference:win32api_ColorReference_ENG}
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
  
; -------------------------------------------------------------------------
.topic win32api_AboutColors_ENG
 About Colors
 ------------
 
 Color can be used to communicate ideas, show relationships
 between items, and improve the appeal and quality of output.
 Windows enables applications to discover the color
 capabilities of given devices and to choose from the
 available colors those that best suit their needs.
 
 This overview provides information on the following topics:
 
 {Color Basics:win32api_ColorBasics_ENG}
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_ColorBasics_ENG
 Color Basics
 ------------
 
 The color capabilities of devices, such as displays and printers,
 can range from monochrome to thousands of colors. Because
 an application may need to generate output for devices throughout
 this range, it should be prepared to handle varying color
 capabilities.
 
 An application can discover the number of colors available for
 a given device by using the GetDeviceCaps function to retrieve
 the NUMCOLORS value. This value specifies the count of colors
 available for use by the application. Usually, this count
 corresponds to a physical property of the output device, such
 as the number of inks in the printer or the number of distinct
 color signals the display adapter can transmit to the monitor.

 Although the NUMCOLORS value specifies the count of colors,
 it does not identify what the available colors are.
 An application can discover what colors are available by
 enumerating all pens having the PS_SOLID type. Because the
 device driver that supports a given device usually has a full
 range of solid pens and because the system requires that solid
 pens have only colors that the device can generate, enumerating
 these pens is often equivalent to enumerating the colors.
 An application can enumerate the pens by using the EnumObjects
 function.
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; ------------------------------------------------------------------------- 
.topic win32api_ColorReference_ENG
 Color Reference
 ---------------
 
 The following elements are associated with color:
 
 {Color Functions:win32api_ColorFunctions_ENG}
 Color Structures
 Color Macros
 Color Messages
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_ColorFunctions_ENG
 Color Functions
 ---------------
 
 The following functions are used with color.
 
 Function                    Description
 --------------------------------------------------------
 {AnimatePalette:win32api_AnimatePalette_ENG}           => Replaces entries in the specified logical
                             palette.
 {CreateHalftonePalette:win32api_CreateHalftonePalette_ENG}    => Creates a halftone palette for the specified
                             device context (DC).
 {CreatePalette:win32api_CreatePalette_ENG}            => Creates a logical palette.
 {GetColorAdjustment:win32api_GetColorAdjustment_ENG}       => Retrieves the color adjustment values for the
                             specified DC.
 {GetNearestColor:win32api_GetNearestColor_ENG}          => Retrieves a color value identifying a color
                             from the system palette that will be displayed
                             when the specified color value is used.
 {GetNearestPaletteIndex:win32api_GetNearestPaletteIndex_ENG}   => Retrieves the index for the entry in the
                             specified logical palette most closely
                             matching a specified color value.
 {GetPaletteEntries:win32api_GetPaletteEntries_ENG}        => Retrieves a specified range of palette entries
                             from the given logical palette.
 {GetSystemPaletteEntries:win32api_GetSystemPaletteEntries_ENG}  => Retrieves a range of palette entries from the
                             system palette that is associated with the
                             specified DC.
 {GetSystemPaletteUse:win32api_GetSystemPaletteUse_ENG}      => Retrieves the current state of the system
                             (physical) palette for the specified DC.
 {RealizePalette:win32api_RealizePalette_ENG}           => Maps palette entries from the current logical
                             palette to the system palette.
 {ResizePalette:win32api_ResizePalette_ENG}            => Increases or decreases the size of a logical
                             palette based on the specified value.
 {SelectPalette:win32api_SelectPalette_ENG}            => Selects the specified logical palette into
                             a device context.
 {SetColorAdjustment:win32api_SetColorAdjustment_ENG}       => Sets the color adjustment values for a DC using
                             the specified values.
 {SetPaletteEntries:win32api_SetPaletteEntries_ENG}        => Sets RGB (red, green, blue) color values and
                             flags in a range of entries in a logical palette.
 {SetSystemPaletteUse:win32api_SetSystemPaletteUse_ENG}      => Allows an application to specify whether the
                             system palette contains 2 or 20 static colors.
 {UnrealizeObject:win32api_UnrealizeObject_ENG}          => Resets the origin of a brush or resets a logical
                             palette.
 {UpdateColors:win32api_UpdateColors_ENG}             => Updates the client area of the specified device
                             context by remapping the current colors in the
                             client area to the currently realized logical
                             palette.
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_AnimatePalette_ENG
 AnimatePalette
 --------------
 
 The AnimatePalette function replaces entries in the specified
 logical palette.
 
 Syntax (C++:
 ------------
 BOOL AnimatePalette(
  [in] HPALETTE           hPal,
  [in] UINT               iStartIndex,
  [in] UINT               cEntries,
  [in] const PALETTEENTRY *ppe
 );
 
 Parameters:
 -----------
 [in] hPal        => A handle to the logical palette.
 [in] iStartIndex => The first logical palette entry to be replaced.
 [in] cEntries    => The number of entries to be replaced.
 [in] ppe         => A pointer to the first member in an array of
                     PALETTEENTRY structures used to replace the
                     current entries.
 
 Return value:
 -------------
 If the function succeeds, the return value is nonzero.
 If the function fails, the return value is zero.
 
 Remarks:
 --------
 An application can determine whether a device supports
 palette operations by calling the GetDeviceCaps function
 and specifying the RASTERCAPS constant.
 
 The AnimatePalette function only changes entries with the
 PC_RESERVED flag set in the corresponding palPalEntry
 member of the LOGPALETTE structure.
 
 If the given palette is associated with the active window,
 the colors in the palette are replaced immediately.
 
 See also:
 ---------
 {Color Functions:win32api_ColorFunctions_ENG}
 {Color Overview:win32api_ColorsOverview_ENG}
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_CreateHalftonePalette_ENG
 CreateHalftonePalette
 ---------------------
 
 The CreateHalftonePalette function creates a halftone
 palette for the specified device context (DC).
 
 Syntax (C++):
 -------------
 HPALETTE CreateHalftonePalette(
  [in] HDC hdc
 );
 
 Parameters:
 -----------
 [in] hdc => A handle to the device context.
 
 Return value:
 -------------
 If the function succeeds, the return value is a handle
 to a logical halftone palette.
 If the function fails, the return value is zero.
 
 Remarks:
 --------
 An application should create a halftone palette when
 the stretching mode of a device context is set to
 HALFTONE.
 The logical halftone palette returned by CreateHalftonePalette
 should then be selected and realized into the device
 context before the StretchBlt or StretchDIBits function
 is called.
 When you no longer need the palette, call the DeleteObject
 function to delete it.
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_CreatePalette_ENG
 CreatePalette
 -------------
 
 The CreatePalette function creates a logical palette.
 
 Syntax (C++):
 -------------
 HPALETTE CreatePalette(
  [in] const LOGPALETTE *plpal
 );
 
 Parameters:
 -----------
 [in] plpal => A pointer to a LOGPALETTE structure that
               contains information about the colors in
               the logical palette.
 
 Return value:
 -------------
 If the function succeeds, the return value is a handle
 to a logical palette.
 If the function fails, the return value is NULL.
 
 Remarks:
 --------
 An application can determine whether a device supports
 palette operations by calling the GetDeviceCaps function
 and specifying the RASTERCAPS constant.
 
 Once an application creates a logical palette, it can
 select that palette into a device context by calling
 the SelectPalette function. A palette selected into a
 device context can be realized by calling the
 RealizePalette function.
 
 When you no longer need the palette, call the
 DeleteObject function to delete it.
 
 See also:
 ---------
 {Color Functions:win32api_ColorFunctions_ENG}
 {Color Overview:win32api_ColorsOverview_ENG}
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_GetColorAdjustment_ENG
 GetColorAdjustment
 ------------------
 
 The GetColorAdjustment function retrieves the
 color adjustment values for the specified device
 context (DC).
 
 Syntax (C++):
 -------------
 BOOL GetColorAdjustment(
  [in]  HDC               hdc,
  [out] LPCOLORADJUSTMENT lpca
 );
 
 Parameters:
 -----------
 [in]  hdc  => A handle to the device context.
 [out] lpca => A pointer to a COLORADJUSTMENT
               structure that receives the color
               adjustment values.
 
 Return value:
 -------------
 If the function succeeds, the return value is nonzero.
 If the function fails, the return value is zero.
 
 See also:
 ---------
 {Color Functions:win32api_ColorFunctions_ENG}
 {Color Overview:win32api_ColorsOverview_ENG}
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_GetNearestColor_ENG
 GetNearestColor
 ---------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_GetNearestPaletteIndex_ENG
 GetNearestPaletteIndex
 ----------------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_GetPaletteEntries_ENG
 GetPaletteEntries
 -----------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_GetSystemPaletteEntries_ENG
 GetSystemPaletteEntries
 -----------------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_GetSystemPaletteUse_ENG
 GetSystemPaletteUse
 -------------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)

 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_RealizePalette_ENG
 RealizePalette
 --------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)

 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_ResizePalette_ENG
 ResizePalette
 -------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)

 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_SelectPalette_ENG
 SelectPalette
 -------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_SetColorAdjustment_ENG
 SetColorAdjustment
 ------------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_SetPaletteEntries_ENG
 SetPaletteEntries
 -----------------

 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_SetSystemPaletteUse_ENG
 SetSystemPaletteUse
 -------------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_UnrealizeObject_ENG
 UnrealizeObject
 ---------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_UpdateColors_ENG
 UpdateColors
 ------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 

; -------------------------------------------------------------------------
.topic win32api_UsingColors_ENG
 Using Colors
 ------------
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_ColorMacros_ENG
 Color Macros
 ------------

 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_COLORREF_ENG
 COLORREF
 --------
 The COLORREF value is used to specify an RGB color.
 
 Example (C++):
 --------------
 // Color constants.
 const COLORREF rgbRed   =  0x000000FF;
 const COLORREF rgbGreen =  0x0000FF00;
 const COLORREF rgbBlue  =  0x00FF0000;
 const COLORREF rgbBlack =  0x00000000;
 const COLORREF rgbWhite =  0x00FFFFFF;
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; -------------------------------------------------------------------------
.topic win32api_HDC_ENG
 HDC
 ---
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_RGB_ENG
 RGB  (wingdi.h)
 ---------------
 
 The RGB macro selects a red, green, blue (RGB) color
 based on the arguments supplied and the color capabilities
 of the output device.
 
 Syntax:
 -------
 void RGB( r,g,b );
 
 Parameters:
 -----------
 r => The intensity of the red color.
 g => The intensity of the green color.
 b => The intensity of the blue color.
 
 Return value:
 -------------
 none
 
 Remarks:
 --------
 The intensity for each argument is in the range 0 through
 255. If all three intensities are zero, the result is black.
 If all three intensities are 255, the result is white.
 
 To extract the individual values for the red, green, and
 blue components of a COLORREF color value, use the
 GetRValue, GetGValue, and GetBValue macros, respectively.

 When creating or examining a logical palette, use the RGBQUAD
 structure to define color values and examine individual
 component values. For more information about using color
 values in a color palette, see the descriptions of the
 PALETTEINDEX and PALETTERGB macros.
 
 See also:
 ---------
 {COLORREF:win32api_COLORREF_ENG}
 {Color Macros:win32api_ColorMacros_ENG}
 {Colors Overview:win32api_ColorsOverview_ENG}
 {GetBValue:win32api_GetBValue_ENG}
 {GetGValue:win32api_GetGValue_ENG}
 {GetRValue:win32api_GetRValue_ENG}
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_GetBValue_ENG
 GetBValue  (wingdi.h)
 ---------------------
 
 The GetBValue macro retrieves an intensity value for the blue
 component of a red, green, blue (RGB) value.
 
 Syntax (C++):
 -------
 void GetBValue(
   rgb
 );
 
 Parameters:
 -----------
 rgb => Specifies an RGB color value.
 
 Return value:
 -------------
 none.
 
 Remarks:
 --------
 The intensity value is in the range 0 through 255.
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; -------------------------------------------------------------------------
.topic win32api_GetGValue_ENG
 GetGValue  (wingdi.h)
 ---------------------
 
 The GetGValue macro retrieves an intensity value for the green
 component of a red, green, blue (RGB) value.
 
 Syntax (C++):
 -------
 void GetGValue(
   rgb
 );
 
 Parameters:
 -----------
 rgb => Specifies an RGB color value.
 
 Return value:
 -------------
 none.
 
 Remarks:
 --------
 The intensity value is in the range 0 through 255.
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)
 
 ════════════════════════════════════════════
 {win32api:win32api_ENG}
 
; -------------------------------------------------------------------------
.topic win32api_GetRValue_ENG
 GetRValue  (wingdi.h)
 ---------------------
 
 The GetRValue macro retrieves an intensity value for the red
 component of a red, green, blue (RGB) value.
 
 Syntax (C++):
 -------
 void GetRValue(
   rgb
 );
 
 Parameters:
 -----------
 rgb => Specifies an RGB color value.
 
 Return value:
 -------------
 none.
 
 Remarks:
 --------
 The intensity value is in the range 0 through 255.
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)

 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; -------------------------------------------------------------------------
.topic win32api_SetBkColor_ENG
 SetBkColor  (wingdi.h)
 ----------------------
 The SetBkColor function sets the current background color
 to the specified color value, or to the nearest physical
 color if the device cannot represent the specified color
 value.
 
 Syntax:
 -------
 COLORREF SetBkColor(
  [in] {HDC:win32api_HDC_ENG}      hdc,
  [in] {COLORREF:win32api_COLORREF_ENG} color
 );
 
 Parameters:
 -----------
 [in] hdc    => A handle to the device context.
 [in] color  => The new background color. To make a {COLORREF:win32api_COLORREF_ENG} value,
                use the {RGB:win32api_RGB_ENG} macro.
 
 Return value:
 -------------
 If the function succeeds, the return value specifies the previous
 background color as a {COLORREF:win32api_COLORREF_ENG} value.

 If the function fails, the return value is CLR_INVALID.
 
 Remarks:
 --------
 This function fills the gaps between styled lines drawn using
 a pen created by the CreatePen function; it does not fill the
 gaps between styled lines drawn using a pen created by the
 ExtCreatePen function. The SetBkColor function also sets the
 background colors for TextOut and ExtTextOut.
 
 If the background mode is OPAQUE, the background color is used
 to fill gaps between styled lines, gaps between hatched lines
 in brushes, and character cells. The background color is also
 used when converting bitmaps from color to monochrome and
 vice versa.
 
 Requirements:
 -------------
 Target Platform => Windows
 Header          => wingdi.h (include windows.h)

 ════════════════════════════════════════════
 {win32api:win32api_ENG}

; -------------------------------------------------------------------------